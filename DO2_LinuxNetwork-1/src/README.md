# Linux Network

Настройка сетей в Linux на виртуальных машинах

## Contents

1. [Инструмент ipcalc](#part-1-инструмент-ipcalc) \
    1.1. [Сети и маски](#11-networks-and-masks) \
    1.2. [localhost](#12-localhost) \
    1.3. [Диапазоны и сегменты сетей](#13-диапазоны-и-сегменты-сетей)
2. [Статическая маршрутизация между двумя машинами ](#part-2-статическая-маршрутизация-между-двумя-машинами) \
    2.1. [Добавление статического маршрута вручную](#21-добавление-статического-маршрута-вручную) \
    2.2. [Добавление статического маршрута с сохранением](#22-добавление-статического-маршрута-с-сохранением)
3. [Утилита iperf3](#part-3-утилита-iperf3) \
    3.1. [Скорость соединения](#31-скорость-соединения) \
    3.2. [Утилита iperf3](#32-утилита-iperf3)
4. [Сетевой экран](#part-4-сетевой-экран-network-firewall) \
    4.1. [Утилита iptables](#41-утилита-iptables) \
    4.2. [Утилита nmap](#42-утилита-nmap)
5. [Статическая маршрутизация сети](#part-5-статическая-маршрутизация-сети) \
    5.1. [Настройка адресов машин](#51-настройка-адресов-машин) \
    5.2 [Включение переадресации IP-адресов](#52-включение-переадресации-ip-адресов) \
    5.3 [Установка маршрута по-умолчанию](#53-установка-маршрута-по-умолчанию) \
    5.4. [Добавление статических маршрутов](#54-добавление-статических-маршрутов) \
    5.5. [Построение списка маршрутизаторов](#55-построение-списка-маршрутизаторов) \
    5.6. [Использование протокола ICMP при маршрутизации](#56-использование-протокола-icmp-при-маршрутизации)
6. [Динамическая настройка IP с помощью DHCP](#part-6-динамическая-настройка-ip-с-помощью-dhcp)
7. [NAT](#part-7-nat)
8. [Знакомство с SSH Tunnels](#part-8-дополнительно-знакомство-с-ssh-tunnels)


## Part 1. Инструмент ipcalc

ipcalc - это командная утилита в Linux, предназначенная для вычисления параметров сети и подсети на основе IP-адреса и маски подсети. 

```c
$ sudo apt install ipcalc
```

### 1.1. Networks and Masks

- IP-адрес (Internet Protocol Address): Это уникальный числовой идентификатор, присваиваемый устройствам в сети для их идентификации и обмена данными. IP-адрес состоит из четырех чисел (октетов), разделенных точками (например, 192.168.1.1). В Linux, как и в других операционных системах, IP-адрес используется для определения конкретного устройства в сети.

- Маска подсети (Subnet Mask): Маска подсети определяет, какая часть IP-адреса относится к сети, а какая - к хосту. Маска представляет собой последовательность битов, где биты сетевой части установлены в 1, а биты хостовой части - в 0. Например, маска 255.255.255.0 (или /24 в CIDR-нотации) означает, что первые 24 бита адреса относятся к сети, а остальные - к хосту.

Определить и записать в отчёт:
1. network address of 192.167.38.54/13

```c
$ ipcalc 192.167.38.54/13
```
![part 1.1 ](misc/part%201.1%20(192.167.38.54:13).png)

      NETWORK - сетевой адрес.
      HOSTMIN - первый доступный хост.
      HOSTMAX - последний доступный хост.
      BROADCAST -  широковещательный адрес.
      HOSTS - общее количество доступных хостов.

- перевод маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную, 11111111.11111111.11111111.11110000 в обычную и префиксную

```c
$ ipcalc 255.255.255.0/15
```
![part 2.2](misc/part%201.2%20ipcalc%20255.255.255.0:15.png)

    NETSMARK - преобразование маски в префиксную = 24.
    ADRESSES - преобразование маски в  двоичную = 11111111.11111111.11111111.00000000.


Маска подсети позволяет компьютеру идентифицировать устройства внутри одной сети, и понимать, кто не в ней. Устройства, находящиеся в пределах одной сети могут обмениваться данными напрямую, а для связи с устройствами из другой сети используют роутер.

![вычисление маски](misc/Vychislenie-maski.png)

|  mask |  default | prefix  | binary  |
|---|---|---|---|
|   255.255.255.0 |  255.255.255.0   |  /24 |   |
| /15  | 255.254.0.0   | /12  |  11111111.11111110.00000000.00000000 |
|  11111111.11111111.11111111.11110000 | 255.255.255.240  |  /28 | 11111111.11111111.11111111.11110000  |


 3. минимальный и максимальный хост в сети 12.167.38.4 при масках: /8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4

- 8 

```c
$ ipcalc 12.167.38.4/8
```
![part 1.3.1](misc/part%201.3.1%20max:min%20host%20.png)

    HOSTMIN - первый доступный хост = 12.0.0.1.
    HOSTMAX - последний доступный хост = 12.255.255.254.



- Минимальный и максимальный хост в сети 12.167.38.4 при маске 11111111.11111111.00000000.00000000

```c
$ ipcalc 12.167.38.4/255.255.0.0
```
![part 1.3.2](misc/part%201.3.2%20min:max%20host.png)

    HOSTMIN - первый доступный хост = 12.167.0.1.
    HOSTMAX - последний доступный хост = 12.167.255.254.


- Минимальный и максимальный хост в сети 12.167.38.4 при маске 255.255.254.0

```c
$ ipcalc 12.167.38.4/255.255.254.0
```
![part 1.3.3](misc/part%201.3.2%20min:max%20host.png)
       
    HOSTMIN - первый доступный хост =  12.167.38.1.
    HOSTMAX - последний доступный хост =  12.167.39.254.


- 4

```c
$ ipcalc 12.167.38.4/4
```
![part 1.3.4](misc/part%201.3.4%20min:max%20host.png)

    HOSTMIN - первый доступный хост =  0.0.0.1.
    HOSTMAX - последний доступный хост =  15.255.255.254.


### 1.2. localhost 

 Define and write in the report whether an application running on localhost can be accessed with the following IPs: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1

> IP localhosts on ranges [127.0.0.1 - 127.255.255.254]

```c
$ ping <IP-адрес>
```

| IPs | access |
|----------|----------|
| 194.34.23.100    | false   |
| 127.0.0.2    | true   |
| 127.1.0.1    | true   |
| 128.0.0.1    | false   |

![part 1.2](misc/part%201.2%20ping%20ip.png)

 ### 1.3 Диапазоны и сегменты сетей

1. какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1

[Read more about ifference private and public IP](https://www.geeksforgeeks.org/difference-between-private-and-public-ip-addresses/) 

```c
$ ipcalc <IP-адрес>
```
![](misc/part%201.3%20public:private%20net.png)

|Private range|   10.0.0.0 – 10.255.255.255|172.16.0.0 – 172.31.255.255|192.168.0.0 – 192.168.255.255|
|-|-|-|-|

 | public | private |
|----------|----------|
| 134.43.0.2    | 10.0.0.45   |
|   192.172.0.1  | 192.168.4.2    |
| 192.172.0.1    | 172.20.250.4    |
| 172.0.2.1    | 172.20.250.4    |
| 172.68.0.2    | 10.10.10.10   |
| 192.169.168.1    | 


2. какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255

Измерение диапазона IP-адресов доступа

```c
$ ipcalc 10.10.0.0/18
```
Возможные ip-адреса находятся в диапазоне [HostMin, HostMax] = [```10.10.0.1```, ```10.10.63.254```].

 | IPs | доступ |
|----------|----------|
| 10.0.0.1    | нет   |
| 10.10.0.2    | да   |
| 10.10.10.10    | да   |
| 10.10.100.1    | нет   |
| 10.10.1.255    | да   |


## Part 2. Статическая маршрутизация между двумя машинами
С помощью команды ip a посмотреть существующие сетевые интерфейсы

 ```c
$ ip a
```

![ip a](misc/part2.1%20ip%20a.png)
<p align="center">
ip a command. Вывод для обеих машин одинаковый 

На ws1 и ws2 отключаем DHCP, меняем адрес и маску на соответсвующие в задании. Прописываем настройки адаптера enp0s8, добавляем его в настройках виртуальной машины с названием intnet (на обоих машинах).


![part 2.1](misc/part%202.1%20change%20adress%20ws1.png)
<p align="center">
ws1

![2.1.2](misc/part%202.1.2%20change%20adress%20ws2.png)
<p align="center">
ws2

- Применяем изменения, используя команду
 ```c
$ sudo netplan apply
```
![part 2.1.3](misc/part%202.3%20netplan%20apply.png)

- Появился новый адаптер с ip 192.168.100.10 и маской /16 на первой машине, на второй  ip 172.24.116.8/12 

![fin](misc/part%202%20result(ws1%20%D0%B8%20ws2).png)
<p align="center">
ws1 и ws2

### 2.1. Добавление статического маршрута вручную

- Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида 

```c
$ ip r add
```
![part 2.2 ws1](misc/part%202.2%20%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0%20ws1.png)
<p align="center">
ws1

![part 2.2 ws2](misc/part%202.2%20%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0%20(ws1).png)
<p align="center">
ws2

- Пропинговать соединение между машинами

![part 2 ws1](misc/part%202.2%20ping%20from%20ws1.png)
<p align="center">
ping from ws1 

![part 2 ws2](misc/part%202.2%20ping%20from%20ws2.png)
<p align="center">
ping from ws2

### 2.2. Добавление статического маршрута с сохранением

- Перезапустить машины

- Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml

![part 2.3 add](misc/part%202.3%20vim%20changes%20ws1.png)
<p align="center">
yaml file ws1

![part 2.3 add](misc/part%202.3%20vim%20changes%20ws2.png)
<p align="center">
yaml file ws2

- Пропинговать соединение между машинами

![part 2.3 res](misc/part%202.3%20result%20ws%201.png)
<p align="center">
ping from ws1

![part 2.3 res](misc/part%202.3%20result%20ws2.png)
<p align="center">
ping from ws2

## Part 3. Утилита iperf3

Утилита iperf3 — широко используемый в Linux инструмент для измерения производительности сети. Это позволяет вам проверить максимально достижимую пропускную способность между двумя устройствами в сети.

### 3.1 Скорость соединения

[gorgeous конвертер единиц](https://convertlive.com/ru/%D0%BA%D0%BE%D0%BD%D0%B2%D0%B5%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C)

- 8 Mbps - 1 MB/s (Мегабит/сек в Мегабайт/сек)
- 100 MB/s - 819200 Kbps, (Мегабайт/сек в Килобит/сек)
- 1 Gbps - 1024 Mbps (Гигабит/сек в Мегабит/сек)

### 3.2 Утилита iperf3

Измерить скорость соединения между ws1 и ws2

Сначала запускаем команду iperf3 -s на виртуалке, которая выступает в роли сервера, затем команду iperf -c 192.168.100.10 (ip сервера) на клиенте.

- Запустите серверную часть на одном компьютере, выполнив следующую команду:

```c
$ iperf3 -s
```
![part 3.2](misc/part%203.2%20iperf%203%20ws1.png)
<p align="center">
ws1 

- На стороне клиента выполните следующую команду, чтобы запустить тест:

```c
$ iperf3 -c <server_ip_address>
```
![part 3.2 done](misc/part%203.2%20done%20iperf3%20ws2.png)
<p align="center">
ws2

## Part 4. Сетевой экран (network firewall)

### 4.1. Утилита iptables

iptables - это инструмент командной строки для настройки межсетевого экрана (фаерволла) в операционных системах Linux. Он позволяет контролировать и управлять трафиком сетевых пакетов, определяя, какие пакеты разрешены, а какие запрещены на различных уровнях.
- Документация по [iptables](https://www.opennet.ru/docs/RUS/iptables/)

Создайте файл /etc/firewall.sh, имитирующий firewall на ws1 и ws2:

Нужно добавить в файл подряд следующие правила:
  - на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5)
  - на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)
  - открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)
  - запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)
  - разрешить echo reply (машина должна "пинговаться")


![part 4.1](misc/part%204.1%20sh%20script%20ws%201.png)
<p align="center">
sh script for ws1
![part 4.1](misc/part%204.2%20sh%20script%20ws2.png)
<p align="center">
sh script for ws2

- Содержимое файла `/etc/firewall.sh` на обеих машинах. Разница заключается в порядке команд, утилита iptables выполняет первое прочитанное правило, соответсвенно на ws1 будет выполнятся запрет и пинг не пройдет, а на ws2 наоборот, первым стоит ACCEPT, разрешить прохождение пакета, пинг пройдет.

выдача прав 
```c
$ sudo chmod +x /etc/firewall.sh 
```
запуск 
```c
$ sudo sh /etc/firewall.sh
```
- Командой ping найти машину, которая не "пингуется"

```c
$ ping <ip-addres>
```

![ws1](misc/part%204.1%20ws1%20chmod%20sh%20+%20ping.png)
<p align="center">
ws1

![](misc/part%204.1%20ws%202%20chmod%20sh%20+%20ping.png)
<p align="center">
ws2
- Правила выполняться сверху-вниз, следовательно, если правило запрета находиться выше оно срабатывает, а правило разрешения находящиеся ниже нет. Следовательно 1ая машина не пингуется, а 2ая пингуется.

### 4.2. Утилита nmap

- Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен

nmap (Network Mapper) - утилита в операционных системах Linux, используемая для сканирования сетей, определения активных устройств, обнаружения открытых портов и выполнения других сетевых задач.

![part 4.2](misc/part%204.2%20nmap.png)
<p align="center">
nmap result for ws2 (a machine which is not pinged) 

## Part 5. Статическая маршрутизация сети

- Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))

### 5.1. Настройка адресов машин

![net](misc/task%20for%205th.png)

- Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке
```c
$ sudo vim /etc/netplan/00-installer-config.yaml
```

![ws11](misc/part%205.1%20address%20ws%2011.png)
<p align="center">
ws11

![ws21](misc/part%205.1%20addres%20ws21.png)
<p align="center">
ws21

![ws22](misc/part%205.1%20address%20ws%2022.png)
<p align="center">
ws22

![r1](misc/part%205.1%20address%20r1.png)
<p align="center">
r1

![r2](misc/part%205.1%20addresses%20r2.png)
<p align="center">
r2

> Перезапустить сервис сети
```c
$ sudo netplan apply
```

Если ошибок нет, то командой ip -4 a проверить, что адрес машины задан верно
```c 
$ ip -4 a
```
![ws11](misc/part%205.1%20ip%204%20ws11.png)
<p align="center">
ws11

![ws21](misc/part%205.1%20ip%20ws21.png)
<p align="center">
ws21

![ws22](misc/part%205.1%20ip%204%20ws22.png)
<p align="center">
ws22

![r1](misc/part%205.1%20ip%204%20r1.png)
<p align="center">
r1

![r2](misc/part%205.1%20ip%204%20r2.png)
<p align="center">
r2

Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.
- Пинг ws22 с ws21
``` shell 
$ ping -c 5 10.20.0.20
```
![ws22 и ws21](misc/part%205.1%20ping%20r1%20ws11.png)
<p align="center">
ws22 и ws21

- Пинг r1 с ws11
``` shell 
$ ping -c 5 10.10.0.1
```
![r1 и ws11](misc/part%205.1%20ping%20ws21%20ws22.png)
r1 и ws11


### 5.2. Включение переадресации IP-адресов.

- Для включения переадресации IP на роутерах (до следующей перезагрузки) используется команда 
``` shell 
$ sudo sysctl -w net.ipv4.ip_forward=1
```

![r1](misc/part%205.2%20%D0%BF%D0%B5%D1%80%D0%B5%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0%D1%86%D0%B8%D0%B8%20IP%20r1.png)

![r2](misc/part%205.2%20%D0%BF%D0%B5%D1%80%D0%B5%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0%D1%86%D0%B8%D0%B8%20IP%20r2.png)

- Откройте файл /etc/sysctl.conf и добавьте в него следующую строку: net.ipv4.ip_forward = 1
With this approach, IP forwarding is enabled permanently.

![r1 r2](misc/5.2%20system%20ipv4.png)
<p align="center">
r1, r2

Конфигурационные параметры ядра хранятся в файле /etc/sysctl.conf (или в файлах в директории /etc/sysctl.d/), и изменения в этом файле вступают в силу только после перезагрузки системы. Однако с помощью команды sudo sysctl -p можно мгновенно применить новые настройки без перезагрузки.

``` shell 
$ sudo sysctl -p
```

### 5.3. Установка маршрута по-умолчанию

Пример вывода команды ip r после добавления шлюза:
```
default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2
```

- Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить default перед IP роутера в файле конфигураций

![ws11](misc/5.3%20change%20addr%20ws11.png)
<p align="center">
ws11
![ws21](misc/5.3%20change%20add%20ws21.png)
<p align="center">
ws21
![ws22](misc/5.3%20change%20add%20ws%2022.png)
ws22

- ip изменения для роутеров

![r1](misc/part%205.3%20ip%20change%20r1.png)
<p align="center">
r1
![r2](misc/part%205.3%20ip%20change%20r2.png)
<p align="center">
r2

``` shell 
$ ip r
```

Команда ip r в Linux используется для вывода таблицы маршрутизации, которая определяет, каким образом сетевые пакеты должны быть перенаправлены между различными сетями и устройствами. 

![ws11](misc/part%205.3%20ip%20r%20ws11.png)
<p align="center">
ws11

![ws21](misc/part%205.3%20ip%20r%20ws21.png)
<p align="center">
ws21

![ws22](misc/part%205.3%20ip%20r%20ws22.png)
<p align="center">
ws22

- Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит. Для этого использовать команду
``` shell 
$ sudo tcpdump -tn -i enp0s3
```

![ping ws11 r2](misc/part%205.3%20ws11%20ping%20r2.png)
<p align="center">
ping ws11 r2

![result](misc/5.3%20result.png)
demonstration of ping ws11 r2

### 5.4. Добавление статических маршрутов

- Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26

![r1 r2](misc/5.4%20r1%20r2%20static%20address.png)

Вызвать ip r и показать таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:
``` brew
ip r
```
![r1](misc/5.4.2%20ip%202%20r1.png)
<p align="center">
r1

![r2](misc/5.4.2%20ip%20r%20r2.png)
<p align="center">
r2 

Запустить команды на ws11:
``` brew
ip r list 10.10.0.0/[18]
ip r list 0.0.0.0/0
```
![ws11](misc/5.4.3%20ws%2011%20ip%20r%20list.png)
<p align="center">
ws11

Для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0, поскольку он является адресом сети и доступен без шлюза.

### 5.5 Построение списка маршрутизаторов

- При помощи утилиты `traceroute` построить список маршрутизаторов на пути от `ws11` до `ws21`

ws11
``` shell 
$ sudo traceroute 10.20.0.10 -n
```
- Запустить на r1 команду дампа

``` shell
$ tcpdump -tnv -i eth0
```

![ws11, r1](misc/5.5%20TRACEROUTE.png)

> Traceroute:
Каждый пакет проходит на своем пути определенное количество узлов, пока достигнет своей цели. Причем, каждый пакет имеет свое время жизни. Это количество узлов, которые может пройти пакет перед тем, как он будет уничтожен. Этот параметр записывается в заголовке TTL, каждый маршрутизатор, через который будет проходить пакет уменьшает его на единицу. При TTL=0 пакет уничтожается, а отправителю отсылается сообщение Time Exceeded.
Команда traceroute linux использует UDP пакеты. Она отправляет пакет с TTL=1 и смотрит адрес ответившего узла, дальше TTL=2, TTL=3 и так пока не достигнет цели. Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят. Когда утилита traceroute получает сообщение от целевого узла о том, что порт недоступен трассировка считается завершенной.


### 5.6 Использование протокола ICMP при маршрутизации
Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:
``` brew
tcpdump -n -i eth0 icmp
```
![r1](misc/5.6%20tcpdump%20for%20r1.png)
<p align="center">
r1

Пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:
``` brew
ping -c 1 10.30.0.111
```

![ws11](misc/5.6%20ping%20of%20ws11%20.png)
<p align="center">
ws11

## Part 6. Динамическая настройка IP с помощью DHCP

1. Для r2 настроить в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP:

![r2 dhcp](misc/6.1%20dhcp%20r2.png)
<p align="center">
r2


Адрес внутренней сети: 10.20.0.0/255.255.255.192 (mask)
Диапазон IP-адресов для присвоения клиентам: 10.20.0.0 - 10.20.0.42
Адрес роутера по умолчанию: 10.20.0.1
DNS-серверы: 10.20.0.1

2. В файле resolv.conf прописать nameserver 8.8.8.8:

![r2](misc/6.2%20nameserver%20r2.png)
<p align="center">
r2

Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server. Машину ws21 перезагрузить при помощи reboot и через ip a показать, что она получила адрес. Также пропинговать ws22 с ws21.

Для `r2`
``` shell 
$ systemctl restart isc-dhcp-server
```
![restart](misc/6.1%20systemctl%20restart.png)

> Для `ws21`
``` shell 
$ reboot
$ ip a
```
![ip a for ws11](misc/6.1%20ip%20a%20for%20ws11.png)
<p align="center">
ws11

![ping ws11 ws22](misc/6.1%20ping%20ws11%20ws22.png)
<p align="center">
ping ws11 ws22


Для r1 настроить аналогично r2, но сделать выдачу адресов с привязкой к MAC-адресу (ws11). Провести аналогичные тесты В файле /etc/dhcp/dhcpd.conf настроить конфигурацию службы DHCP с привязкой к MAC-адресу (ws11)

![macaddress ws11](misc/6.1%20macaddress%20ws11.png)

![dhcp r1](misc/6.1%20dhcp%20r1.png)


![resolv r1](misc/6.1%20resolv%20r1.png)

Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server.
Машину ws11 перезагрузить при помощи reboot и через ip a показать, что она получила адрес.

``` shell
$ systemctl restart isc-dhcp-server
```

![restart r1](misc/6.1%20systemctl%20restart.png)

- Обновление адреса для машины ws21 при помощи запроса его у dhcp сервера при помощи команды

``` shell
$ sudo dhclient -r enp0s3
$ sudo dhclient enp0s3
```

![result ws21](misc/6.1%20result%20ws%2021.png)
<p align="center">
до
![sudo dhclient -r enp0s3](misc/6.1%20ws%2021%20after%20dhclient.png)
<p align="center">
после 

- dhclient -r enp0s8

сообщает клиенту DHCP освободить все ранее присвоенные сетевые настройки и адреса IP для интерфейса enp0s8.
"dhclient" - это клиент DHCP (Dynamic Host Configuration Protocol), который позволяет вашему компьютеру автоматически получать IP-адрес и другие сетевые настройки от DHCP-сервера в вашей сети.
"-r" - это опция команды dhclient, которая указывает клиенту DHCP освободить все ранее присвоенные настройки и адреса IP.
"enp0s8" - это имя сетевого интерфейса, к которому применяется команда. В данном случае, enp0s8 является именем интерфейса Ethernet.
- dhclient enp0s8

Назначает новый ip адрес нашему интерфейсу. DHCP клиент начинает процесс поиска доступного DHCP сервера в сети и просит сервер предоставить ему IP-адрес, субнет-маску, шлюз по умолчанию и другую информацию, необходимую для правильной настройки сетевого соединения на интерфейсе "enp0s8".
После успешного выполнения команды, ваш компьютер получит сетевые настройки от DHCP сервера и сможет использовать соответствующую сеть для связи с другими устройствами в сети.


## Part 7. NAT

- В файле `/etc/apache2/ports.conf` на ws22 и r1 изменить строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступным

``` shell
$ sudo apt install apache2
```

![apache2 r1](misc/7.1%20apache2%20r1.png)
<p align="center">
r1

![apache2 ws22](misc/7.1%20apache2%20ws22.png) [](misc/images) 
<p align="center">
ws22

- Запустить веб-сервер Apache командой service apache2 start на ws22 и r1

![7.1 apache2 start/status r1](misc/7.1%20apache2%20start:status%20r1.png)

![7.1 apache2 start/status ws22](misc/7.1%20apache2%20start:status%20ws22.png)

Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:

* Удаление правил в таблице filter - iptables -F

* Удаление правил в таблице "NAT" - iptables -F -t nat
* Отбрасывать все маршрутизируемые пакеты - iptables --policy FORWARD DROP

![firewall.sh](misc/7.1%20firewall%20r2.png)
<p align="center">
firewall r2

``` shell
$ sudo chmod +x /etc/firewall.sh
$ sudo sh /etc/firewall.sh
```

> При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1;

``` shell
$ ping -c 3 10.100.0.11
```

![ping ws22 r1](misc/7.1%20no%20ping%20ws%2022%20r1.png)
<p align="center">
ping ws22 r1

> Добавить в файл ещё одно правило:

- Разрешить маршрутизацию всех пакетов протокола ICMP;

![firewall changes r2](misc/7.1%20firewall%20changes%20r2.png)

- Проверить соединение между `ws22` и `r1` командой `ping`

``` shell
$ ping 10.100.0.11
```

![ping ws22 r1 firewall](misc/7.4%20ping%20ws22%20r1%20firewall.png)
<p align="center">
check ws22 r1 ping

Добавить в файл ещё два правила:

- Включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0) 
- Включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети

![r2 firewall](misc/7.5%20r2%20firewall.png)

- iptables -F - Удаляет все правила фильтрации (filter).
- iptables -t nat -F - Удаляет все правила NAT.
- iptables --policy FORWARD ACCEPT - Устанавливает политику действия для цепочки FORWARD на ACCEPT. Это означает, что по умолчанию все пакеты, проходящие через межсетевой экран (firewall), будут разрешены для пересылки.
- iptables -A FORWARD -p icmp -j ACCEPT - Добавляет правило в цепочку FORWARD, разрешающее ICMP пакеты (ping).
- iptables -A FORWARD -i eth0 -j ACCEPT - Добавляет правило в цепочку FORWARD, разрешающее все входящие пакеты на интерфейсе eth0.
- iptables -t nat -A POSTROUTING -s 10.20.0.0/26 -j SNAT --to-source 10.100.0.12 . Добавляет правило в цепочку POSTROUTING для изменения исходного IP-адреса источника (Source NAT). В данном случае, пакеты с исходным адресом из диапазона 10.20.0.0/26 будут заменены на 10.100.0.12 перед отправкой.
- iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 10.20.0.20:80 - Добавляет правило в цепочку PREROUTING для изменения целевого IP-адреса и порта назначения (Destination NAT). В данном случае, пакеты TCP, поступающие на порт 8080, будут перенаправлены на адрес 10.20.0.20 и порт 80.

- Проверить соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1. \
- Проверить соединение по TCP для DNAT, для этого с r1 подключиться к серверу Apache на ws22 командой `telnet`

![telnet ws22](misc/7.5%20telnet%20ws22.png)
<p align="center">
telnet ws22

![telnet r1](misc/7.5%20telnet%20r1.png)
telnet r1

## Part 8. Дополнительно. Знакомство с SSH Tunnels

- Запустить веб-сервер Apache на ws22 только на localhost (то есть в файле `/etc/apache2/ports.conf` изменить строку Listen 80 на Listen localhost:80);

``` shell
$ sudo nano /etc/apache2/ports.conf
```
-Запустить на r2 фаервол с правилами из Части 7
![changes in firewall in r2](misc/8.1%20changes%20in%20firewall%20in%20r2.png)

``` shell
$ sudo chmod +x /etc/firewall.sh
$ sudo sh /etc/firewall.sh
```

- Запустить веб-сервер Apache на ws22 только на localhost (то есть в файле /etc/apache2/ports.conf изменить строку Listen 80 на Listen localhost:80)

``` shell
$ sudo nano /etc/apache2/ports.conf
```

![apache2 ws22](misc/8.1%20ws22%20ports.conf:apache2.png)
<p align="center">
apache ws22

``` shell
$ service apache2
$ sudo service apache status
``` 

![apache2 ws22 start](misc/8.2%20apache2%20ws22%20start.png)
![apache2 ws22 status](misc/8.2%20apache2%20ws22%20status.png)
<p align="center">
apache ws22

Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21

``` shell
$ sudo apt install openssh-server
$ ssh -L [local_port]:localhost:[local_port] [remote_ip]
$ ssh -L 3333:localhost:80 ws21 -p 22
```

![Local TCP forwarding с ws21 до ws22](misc/8.3%20openssh%20ws22%20.png)
<p align="center">
доступ к веб-серверу на ws22 с ws21

-Воспользоваться Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11

``` shell
$ sudo apt install openssh-server
$ ssh -L [local_port]:localhost:[local_port] [remote_ip]
$  ssh -R 4444:localhost:80 -p 22 ws11
```

![remate connection ws22 ws11](misc/8.1%20remate%20connection%20ws22%20ws11.png)
<p align="center">
доступ к веб-серверу на ws22 с ws11

Для проверки, сработало ли подключение в обоих предыдущих пунктах, перейдите во второй терминал (например, клавишами Alt + F2) и выполните команду

``` shell
$ telnet 127.0.0.1 [локальный порт]
```

![telnet check ws11](misc/8%20telnet%20check%20ws11.png)

![telnet check ws22](misc/8%20telnet%20check%20ws22.png)
<p align="center">
проверка подключений на ws11, ws22
